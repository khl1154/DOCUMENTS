SQL 최적화 기본 원리 > 조인 수행 원리

세 개의 테이블 중에서 먼저 두 개의 테이블에 대해 조인이 수행
그리고 먼저 수행된 조인 결과와 나머지 테이블 사이에서 조인이 수행
1. NL JOIN
NL Join은 프로그래밍에서 사용하는 중첩된 반복문과 유사한 방식으로 조인을 수행한다. 
반복문의 외부에 있는 테이블을 선행 테이블 또는 외부 테이블(Outer Table)이라고 하고, 
반복문의 내부에 있는 테이블을 후행 테이블 또는 내부 테이블(Inner Table)이라고 한다.

① 선행 테이블에서 주어진 조건을 만족하는 행을 찾음 
② 선행 테이블의 조인 키 값을 가지고 후행 테이블에서 조인 수행
③ 선행 테이블의 조건을 만족하는 모든 행에 대해 1번 작업 반복 수행

추출버퍼는 SQL문의 실행결과를 보관하는 버퍼로서 일정 크기를 설정하여 추출버퍼에 결과가 모두 차거나 더 이상 결과가 없어서 
추출버퍼를 채울 것이 없으면 결과를 사용자에게 반환
 선행 테이블에 사용 가능한 인덱스가 존재한다면 인덱스를 통해 선행 테이블을 액세스
그래서 결과를 가능한 빨리 화면에 보여줘야 하는 온라인 프로그램에 적당한 조인 기법이다.

2. SORT MERGE JOIN
조인 칼럼을 기준으로 데이터를 정렬하여 조인을 수행
NL Join은 주로 랜덤 액세스 방식으로 데이터를 읽는 반면
 Sort Merge Join은 주로 스캔 방식으로 데이터를 읽는다
 칼럼의 인덱스를 사용하지 않기 때문에 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 조인 기법

3. HASH JOIN
조인을 수행할 테이블의 조인 칼럼을 기준으로 해쉬 함수를 수행하여 
서로 동일한 해쉬 값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인을 수행
Hash Join은 조인 칼럼의 인덱스를 사용하지 않기 때문에
조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 조인 기법
즉, 동등 조인에서만 사용할 수 있다






SQL 최적화 기본 원리 > 인덱스 기본
인덱스 특징과 종류
즉, 검색 조건을 만족하는 데이터를 인덱스를 통해 효과적으로 찾을 수 있도록 돕는다. 
그렇지만 Insert, Update, Delete 등과 같은 DML 작업은 테이블과 인덱스를 함께 변경해야 하기 때문에 오히려 느려질 수 있다는 단점이 존재





트리기반인덱스

리프 블록은 트리의 가장 아래 단계에 존재한다. 리프 블록은 인덱스를 구성하는 칼럼의 데이터와
 해당 데이터를 가지고 있는 행의 위치를 가리키는 레코드 식별자로 구성

인덱스 데이터는 인덱스를 구성하는 칼럼의 값으로 정렬된다. 
만약 인덱스 데이터의 값이 동일하면 레코드 식별자의 순서로 저장

리프 블록은 양방향 링크(Double Link)를 가지고 있다. 이것을 통해서 오름 차순(Ascending Order)과 내림 차순(Descending Order) 검색을 쉽게 할 수 있다




SQL SERVER의 클러스터형 인덱스
SQL Server의 인덱스 종류는 저장 구조에 따라 클러스터형(clustered) 인덱스와 비클러스터형(nonclustered) 인덱스로 나뉨
첫째, 인덱스의 리프 페이지가 곧 데이터 페이지
 둘째, 리프 페이지의 모든 로우(=데이터)는 인덱스 키 칼럼 순으로 물리적으로 정렬되어 저장





테이블 스캔 방식

전체 테이블 스캔 
조건에 맞으면 결과로서 추출하고 조건에 맞지 않으면 버리는 방식으로 검색
1) 쿼리문에 조건이 존재하지 않는 경우
2) SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하는 않는 경우
3) 옵티마이저의 취사 선택
4)병렬처리 방식으로 처리하는 경우 또는
 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있다.



인덱스 스캔
* 인덱스를 구성하는 칼럼의 값을 기반으로 데이터를 추출하는 액세스 기법
  리프블록 - 인덱스를 구성하는 칼럼 + 레코드 식별자
 인덱스에 존재하지 않는 칼럼의 값이 필요한 경우에는 현재 읽은 레코드 식별자를 이용하여 테이블 액세스 해야함
 인덱스는 구성 칼럼의 순서로 정렬



인덱스의 구성 칼럼이 A+B라면 먼저 칼럼 A로 정렬되고 칼럼 A의 값이 동일할 경우에는 칼럼 B로 정렬된다. 
그리고 칼럼 B까지 모두 동일하면 레코드 식별자로 정렬


인덱스 유일 스캔 
	-유일 인덱스(Unique Index)를 사용하여 단 하나의 데이터를 추출하는 방식
	 인덱스 구성 칼럼에 대해 모두 ‘=’로 값이 주어진 경우에만 가능

인덱스 범위 스캔
	-인덱스를 이용하여 한 건 이상의 데이터를 추출하는 방식
	-유일 인덱스의 구성 칼럼 모두에 대해 ‘=’로 값이 주어지지 않은 경우와
	 비유일 인덱스(Non-Unique Index)를 이용하는 모든 액세스 방식


전체 테이블 스캔과 인덱스 스캔 방식의 비교
	오른쪽 그림과 같이 인덱스의 리프 블록의 양방향 링크를 이용하여 내림 차순으로 데이터를 읽는 방식
	최대값(Max Value)을 쉽게 찾을 수 있다


규칙기반 옵티마이저
한번의 I/O 요청에 한 블록씩 데이터를 읽는다. 그러나 전체 테이블 스캔은 데이터를 읽을 때 한번의 I/O 요청으로 
여러 블록을 한꺼번에 읽는다. 어차피 테이블의 모든 데이터를 읽을 것이라면 한 번 읽기 작업을 할 때 여러 블록을 함께 읽는 것이 효율적이다. 
대용량 데이터 중에서 극히 일부의 데이터를 찾을 때, 
인덱스 스캔 방식은 인덱스를 이용해 몇 번의 I/O만으로 원하는 데이터를 쉽게 찾을 수 있다